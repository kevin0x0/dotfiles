#!/bin/sh

call() {
  code=$(jq -r '.code' <"$1")
  intent=$(jq -r '.intent' <"$1")
  {
    printf "\033[31mREQUEST TO EXECUTE COMMAND(s):\033[0m\n"
    printf "%s" "$code" | tr '\n' '\000' | xargs -r0 printf "\033[1;31m|\033[0m \033[32;1m%s\033[0m\n"
    printf "\033[31mCOMMAND EXECUTION INTENT:\033[0m\n"
    printf "%s" "$intent" | tr '\n' '\000' | xargs -r0 printf "\033[1;31m=\033[0m \033[33;1m%s\033[0m\n"
    printf "\033[1;31mDo you approve the request(Y/n/[r]eplace the original command(s))?\033[0m\n"
  } >&2
  IFS= read -r reply
  case "$reply" in
    y|"")
      sh -c "$code" 2>&1
      ;;
    n)
      printf "\033[1;36mEnter your reason(one line):\033[0m\n">&2
      IFS= read -r reason
      printf "!!!!!REQUEST REJECTED!!!!!\n User's reason: %s\n" "$reason"
      ;;
    r)
      printf "\033[1;36mEnter your replacing command, which will be piped to sh:\033[0m\n" "$reason" >&2
      cat | sh 2>&1
      ;;
  esac
}

case "$1" in
  call)
    call "$2"
    ;;
  description)
    jq -Rc '.' <<EOF
Request to execute given POSIX shell script and output result. Note:
  - The request may be rejected.
  - The script should terminate.
  - Don't change system's state unless it is exactly what user wants or
    is necessary to achieve user's request.
EOF
    ;;
  parameters)
    printf '{
      "code": {
        "type": "string",
        "description": "The code to be executed."
      },
      "intent": {
        "type": "string",
        "description": "Your intent to execute this script."
      }
    }'
    ;;
  *)
    printf "Unknown subcommand: %s\n" "$1"
    ;;
esac

