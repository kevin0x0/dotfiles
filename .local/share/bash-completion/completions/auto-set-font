_comp_auto_set_font_list_options() {
  local -a options=(
    --font -f
    --monofont -m
    --reload -r
  )
  local prefix="$1"
  for ((i = 0 ; i < "${#options[@]}"; ++i)); do
    if [[ "${options[i]}" =~ ^$prefix ]]; then
      COMPREPLY+=("${options[i]}")
    fi
  done
}

# remove leading ' and "
_comp_auto_set_font_unquote() {
  local unquoted="${1#\"}"
  echo "${unquoted#"'"}"
}

_comp_auto_set_font() {
  local cur="${COMP_WORDS[COMP_CWORD]}" prev="${COMP_WORDS[COMP_CWORD - 1]}"

  local cur_is_quoted=

  case "$cur" in
    \'*|\"*)
      cur=${cur#?}
      cur_is_quoted=yes
      ;;
  esac

  # If the word isn't quoted, let 'read' interpret escape sequences like '\ '
  if [ -z "$cur_is_quoted" ]; then
    read cur <<<"$cur"
  fi

  # Now we get relatively clean word to generate its completion

  case "$prev" in
    --font|-f)
      local oIFS="${IFS+_$IFS}"
      IFS=$'\n'; COMPREPLY=($(fc-list : family | cut -d ',' -f 1 | grep "^$cur" | sort | uniq))
      ${oIFS:+false} unset -v IFS || IFS=${oIFS#_}

      if [ -z "$cur_is_quoted" ]; then
        COMPREPLY=("${COMPREPLY[@]// /'\ '}")
      fi
      ;;
    --monofont|-m)
      local oIFS="${IFS+_$IFS}"
      IFS=$'\n'; COMPREPLY=($(fc-list :spacing=100 family | cut -d ',' -f 1 | grep "^$cur" | sort | uniq))
      ${oIFS:+false} unset -v IFS || IFS=${oIFS#_}

      if [ -z "$cur_is_quoted" ]; then
        COMPREPLY=("${COMPREPLY[@]// /'\ '}")
      fi
      ;;
    *)
      _comp_auto_set_font_list_options "$cur"
      ;;
  esac
}

complete -o nosort -F _comp_auto_set_font auto-set-font

# vim: ft=bash
